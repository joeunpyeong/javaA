import java.util.Random;
import java.util.Scanner;

public class Tetris {
    // 보드판 크기와 블록 크기를 상수로 정의
    private static final int BOARD_WIDTH = 10;
    private static final int BOARD_HEIGHT = 20;
    private static final int BLOCK_SIZE = 4;
    
    // 보드판과 블록 배열을 멤버 변수로 선언
    private int[][] board;
    private int[][] block;
    
    // 블록 모양을 저장하는 배열
    private static final int[][][] BLOCK_SHAPES = {
            { { 1, 1, 1, 1 } }, // I 모양 블록
            { { 1, 1, 0 }, { 0, 1, 1 } }, // S 모양 블록
            { { 0, 1, 1 }, { 1, 1, 0 } }, // Z 모양 블록
            { { 1, 1, 1 }, { 0, 1, 0 } }, // T 모양 블록
            { { 1, 1 }, { 1, 1 } }, // O 모양 블록
            { { 1, 0, 0 }, { 1, 1, 1 } }, // L 모양 블록
            { { 0, 0, 1 }, { 1, 1, 1 } }, // J 모양 블록
    };
    
    // 랜덤으로 블록 모양을 선택하기 위한 Random 객체
    private Random random = new Random();
    
    // 게임 오버 여부를 저장하는 변수
    private boolean gameOver = false;
    
    // 생성자에서 보드판을 초기화하고 첫 번째 블록을 생성
    public Tetris() {
        board = new int[BOARD_HEIGHT][BOARD_WIDTH];
        newBlock();
    }
    
    // 새로운 블록을 생성하는 메서드
    private void newBlock() {
        // 랜덤으로 블록 모양을 선택
        int[][] shape = BLOCK_SHAPES[random.nextInt(BLOCK_SHAPES.length)];
        // 블록 배열을 새로 생성하고 모양을 복사
        block = new int[shape.length][shape[0].length];
        for (int i = 0; i < shape.length; i++) {
            for (int j = 0; j < shape[i].length; j++) {
                block[i][j] = shape[i][j];
            }
        }
        // 블록을 보드판 가운데에 위치시킴
        int x = (BOARD_WIDTH - BLOCK_SIZE) / 2;
        int y = 0;
        if (!canPlaceBlock(x, y)) {
            gameOver = true; // 게임 오버
        }
    }
    
    // 블록을 보드판에 놓을 수 있는지 검사하는 메서드
    private boolean canPlaceBlock(int x, int y) {
        for (int i = 0; i < BLOCK_SIZE; i
